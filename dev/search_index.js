var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = georectification","category":"page"},{"location":"#georectification","page":"Home","title":"georectification","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for georectification.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [georectification]","category":"page"},{"location":"#georectification.Coords!-Tuple{DataFrames.DataFrame, String, Float64, Float64, Bool}","page":"Home","title":"georectification.Coords!","text":"Coords!(df::DataFrame,\n        lcf_path::String,\n        z_ground::Float64,\n        θ::Float64,\n        flipped::Bool)\n\nCompute the ground coordinates for each pixel of an HSI df. Update the original df to include\n\nlatitude\nlongitude\naltitude\npixeltimes\nroll\npitch\nheading\n\nand return start_time in UTC corresponding to pixeltime = 0.0.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.DuringFlight-Tuple{DataFrames.DataFrame, DataFrames.DataFrame}","page":"Home","title":"georectification.DuringFlight","text":"function DuringFlight(df_flir, df_lcf)\n\nGiven a master lcf list df_lcf, return a all rows of df_flir that occur during the flight\n\n\n\n\n\n","category":"method"},{"location":"#georectification.DuringFlight-Tuple{DataFrames.DataFrameRow, DataFrames.DataFrame}","page":"Home","title":"georectification.DuringFlight","text":"function DuringFlight(flir_row, df_lcf)\n\nCheck if a row from a Flir Summary csv, flir_row occurred during flight detailed in df_lcf\n\n\n\n\n\n","category":"method"},{"location":"#georectification.HSI_2_RGB-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Home","title":"georectification.HSI_2_RGB","text":"HSI_2_RGB(λs_spec::AbstractVector, HSI::AbstractMatrix, d::Int)\n\nConvert reflectance data from an HSI to an RGB representation.\n\nArguments\n\nλs_spec::AbstractVector`: Wavelength values in nm of the spectrum\nHSI::AbstractMatrix:  Matrix of reflectance or radiance values with shape npixels x nbands\nd::Int: 50, 55, 65, 75. Determines the illuminant used. If in doubt, use d=65.\n\nSource: M. Magnusson, J. Sigurdsson, S. E. Armansson, M. O. Ulfarsson, H. Deborah and J. R. Sveinsson, \"Creating RGB Images from Hyperspectral Images Using a Color Matching Function,\" IGARSS 2020 - 2020 IEEE International Geoscience and Remote Sensing Symposium, 2020, pp. 2045-2048, doi: 10.1109/IGARSS39084.2020.9323397.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.Rotate-Tuple{Any, Any, Any}","page":"Home","title":"georectification.Rotate","text":"Rotate(heading, pitch, roll)\n\nReturn a rotation matrix corresponding to the given orientation angles.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.Spec_2_RGB-Tuple{AbstractVector, AbstractMatrix, Int64}","page":"Home","title":"georectification.Spec_2_RGB","text":"Spec_2_RGB(λs_spec::AbstractVector, Spectrum::AbstractVector, d::Int)\n\nConvert a pixel spectrum from an HSI to an RGB representation.\n\nArguments\n\nλs_spec::AbstractVector`: Wavelength values in nm of the spectrum\nSpectrum::AbstractVector: Vector of reflectance or radiance values\nd::Int: 50, 55, 65, 75. Determines the illuminant used. If in doubt, use d=65.\n\nSource: M. Magnusson, J. Sigurdsson, S. E. Armansson, M. O. Ulfarsson, H. Deborah and J. R. Sveinsson, \"Creating RGB Images from Hyperspectral Images Using a Color Matching Function,\" IGARSS 2020 - 2020 IEEE International Geoscience and Remote Sensing Symposium, 2020, pp. 2045-2048, doi: 10.1109/IGARSS39084.2020.9323397.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.TIFFtoTemp-Tuple{AbstractArray}","page":"Home","title":"georectification.TIFFtoTemp","text":"TIFFtoTemp(img)\n\nConvert a FLIR thermal image to temperature units in °C\n\n\n\n\n\n","category":"method"},{"location":"#georectification.exiftool-Tuple{Any}","page":"Home","title":"georectification.exiftool","text":"function exiftool(imgpath)\n\nRun the command line tool exiftool on the image at imgpath. Returns a dictionary of metadata from the image file. \n\n\n\n\n\n","category":"method"},{"location":"#georectification.generateDerivedMetrics!-Tuple{DataFrames.DataFrame, Array{Float64}}","page":"Home","title":"georectification.generateDerivedMetrics!","text":"generateDerivedMetrics!(df::DataFrame, λs::Array{Float64})\n\nGiven a dataframe df with HSI data, compute a variety of derived wavelength indices such as the NDVI.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.generateFlirSummaries-Tuple{String}","page":"Home","title":"georectification.generateFlirSummaries","text":"function generateFlirSummaries(basepath::String)\n\nLoop through directories in basepath and generate dataframes with capture times for all FLIR images in each folder.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.generateReflectance!-Tuple{DataFrames.DataFrame, String, String, String, Vector{Float64}}","page":"Home","title":"georectification.generateReflectance!","text":"generateReflectance!(df::DataFrame, specPath::String, specHdrPath::String, calibrationPath::String, wavelengths::Array{Float64, 1})\n\nGiven a dataframe df containing the radiance data, generate reflectance data using collected irradiance spectrum and Resonon-supplied calibration data.\n\nNOTE\n\nThe conversion assumes a Lambertian surface. This is clearly not the case for water that isn't perfectly still.\n\nNOTE Also add the corrected radiance spectrum values as additional features.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.georectify-Tuple{String, String, String, String, String, String, String, Array{Float64}, Float64, Float64, Bool, Int64}","page":"Home","title":"georectification.georectify","text":"georectify(bilpath::String,\n           bilhdrpath::String,\n           timespath::String,\n           specpath::String,\n           spechdrpath::String,\n           calibrationpath::String,\n           lcfpath::String,\n           λs::Array{Float64},\n           z_ground::Float64,\n           θ_view::Float64,\n           isFlipped::Bool,\n           ndigits::Int,\n           )\n\nGenerate a georectified dataframe including radiance, reflectance, derived metrics, utc_time, and position data.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.georectifyFLIR-Tuple{String, String, String, Dates.DateTime, Float64, Float64}","page":"Home","title":"georectification.georectifyFLIR","text":"function georectifyFLIR(thermal_path::String, visible_path::String, lcf_path::String, capture_time::DateTime, z_ground::Float64)\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getBackgroundTile-Tuple{Float64, Float64, Float64, Float64, String}","page":"Home","title":"georectification.getBackgroundTile","text":"getBackgroundTile(w::Float64, n::Float64, e::Float64, s::Float64, outName::String)\n\nGrab Esri World Imagery tiles for region with corners (w,n), (e,s) in longitude and latitude. Saves resulting image to outpath\n\nNote: result images are saved in Web-Mercator projection by default. See WebMercatorfromLLA and LLAfromWebMercator from Geodesy.jl for conversion details.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getExifDate-Tuple{Dict}","page":"Home","title":"georectification.getExifDate","text":"function getExifDate(dict)\n\nGiven a dictionary dict returned from exiftool, return the correct time field as a DateTime object.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getExifDate-Tuple{String}","page":"Home","title":"georectification.getExifDate","text":"function getExifDate(tiffpath::String)\n\nDispatch that returns the time of creation of a FLIR tiff file using exiftool\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getFlirTimes-Tuple{Any, Any}","page":"Home","title":"georectification.getFlirTimes","text":"function getFlirTimes(dirPath, tz)\n\nGiven directory dirPath, generate a list of all FLIR files and their associated time of capture. Assume the time used is in timezone tz. See the TimeZones.jl docs for more information.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getFlirTimes-Tuple{Any}","page":"Home","title":"georectification.getFlirTimes","text":"function getFlirTimes(dirPath)\n\nCalls getFlirTimes on dirPath with the timezone assumed to be US/Central\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getHSIFlightData-Tuple{DataFrames.DataFrame, String}","page":"Home","title":"georectification.getHSIFlightData","text":"getHSIFlightData(df::DataFrame, lcf_path::String)\n\nGiven IMU data found at lcf_path, compute the position and orientation of the Aerial Vehicle at time of capture for each pixel. Return's a dataframe and the corresponding start time of the acquisition reported in UTC.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getHdrFile-Tuple{String}","page":"Home","title":"georectification.getHdrFile","text":"getHdrFile(pathToHdrFile::String)\n\nRead an ENVI-style header file and return a dictionary with image metadata.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getIMUdata-Tuple{String}","page":"Home","title":"georectification.getIMUdata","text":"getIMUdata(pathToLCF::String)\n\nRead a .lcf file and return a DataFrame df with corresponding IMU data and the value start_time indicating the start time of the clock in linux epoch time. start_time is reported as UTC.\n\nData Returned\n\ntime: system time in seconds starting at zero\nroll: angle in radians.\npitch: angle in radians.\nheading: aka yaw. angle in radians.\nlongitude: GPS longitude in degrees, negative for west longitudes\nlatitude: GPS latitude in degrees\naltitude: height in meters above the WGS-54 ellipsoid\nx: x coordinate in meters in UTMz coordinate system\ny: y coordinate in meters in UTMz coordinate system\nz: z coordinate in meters in UTMz coordinate system\nzone: the UTM zone for the local coordinate system\nisnorth: boolean for whether or not position is above equator\n\nNOTES\n\nThe conversion between GPS time and Unix Epoch time was a little confusing. It is good to double check that this is correct (how should we deal with leap seconds?). This is relevant for parsing data from the FLIR as well.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.getTimes-Tuple{String}","page":"Home","title":"georectification.getTimes","text":"getTimes(pathToTimes::String)\n\nRead a .times and return values starting at t=0. Times are assumed to be aligned with the corresponding .lcf file.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.gpsToUTC-Tuple{Any, Any}","page":"Home","title":"georectification.gpsToUTC","text":"function gpsToUTC(gps_sec, year)\n\nGiven the gps_time in seconds and the current year, return the UTC time accounting for leap seconds. See this Stack Overflow Post for more details.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.ilat_ilon!-Tuple{DataFrames.DataFrame, Any}","page":"Home","title":"georectification.ilat_ilon!","text":"ilat_ilon!(df::DataFrame, ndigits)\n\nUpdate a dataframe to include the rounded coordinates ilat and ilon with ndigits of precision.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.ilat_ilon!-Tuple{DataFrames.DataFrame}","page":"Home","title":"georectification.ilat_ilon!","text":"ilat_ilon!(df::DataFrame)\n\nDispatch of ilat_ilon() to use default value of 6 for ndigits.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.imagecoords-NTuple{4, Any}","page":"Home","title":"georectification.imagecoords","text":"imagecoords(i, j, N, f)\n\nGiven pixel indices i and j, compute the coordinates of a HSI pixel in the image coordinate system. The height is the focal length f, and the pixels are assumed to lie along the y-axis.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.imagecoordsFlipped-NTuple{4, Any}","page":"Home","title":"georectification.imagecoordsFlipped","text":"imagecoordsFlipped(i, j, N, f)\n\nSame as imagecoord() but with the y axis flipped. This is useful in case the camera settings for direction of flight are backwards.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.leap_count-Tuple{Int64}","page":"Home","title":"georectification.leap_count","text":"function leap_count(year::Int)\n\nDetermine the number of leap seconds introduced before the given date. See the links below:\n\nStack Overflow Post\nOfficial Leap Seconds Table\n\n\n\n\n\n","category":"method"},{"location":"#georectification.masterLCF-Tuple{String, String}","page":"Home","title":"georectification.masterLCF","text":"masterLCF(folder::String)\n\nLoop through all .lcf files in folder and return a DataFrame containing the start and end times for each datacube aquisition. Start and end times are reported as UTC times.\n\nFields\n\npaths: Paths to each HSI directory\nfiles: file name for .lcf files\ntstart: starting time for each datacube acquisition\ntend: ending time for each datacube acquisition\n\n\n\n\n\n","category":"method"},{"location":"#georectification.matchLCFfile!-Tuple{Any, Any}","page":"Home","title":"georectification.matchLCFfile!","text":"function matchLCfile(df_flir, df_lcf)\n\nGiven a table of flir files and the master lcf file, add a column specifying which lcfpath goes with each row in the flirdf. Rows that do not have a match are given type :missing.\n\n\n\n\n\n","category":"method"},{"location":"#georectification.plot_background-Tuple{Any, Any, Any}","page":"Home","title":"georectification.plot_background","text":"plot_background(sat_tile, longitudes, latitudes)\n\nGiven a satellite background tile sat_tile and associated longitude and latitude ranges, construct a plot \n\n\n\n\n\n","category":"method"},{"location":"#georectification.readToDataFrame","page":"Home","title":"georectification.readToDataFrame","text":"readToDataFrame(pathToBinaryFile::String, pathToHdrFile::String, pathToTimesFile::String)\n\nRead ENVI file with corresponding header (.hdr) and times (.times) file and return a DataFrame containing the image data flattened to (nbands, ncols*nrows).\n\n\n\n\n\n","category":"function"}]
}
